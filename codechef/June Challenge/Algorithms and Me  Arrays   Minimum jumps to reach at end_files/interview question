// API callback
related_results_labels_thumbs({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170"},"updated":{"$t":"2014-06-15T11:11:58.181+05:30"},"category":[{"term":"algorithms"},{"term":"binary search tree"},{"term":"Dynamic Programming"},{"term":"arrays"},{"term":"interview question"},{"term":"Operating Systems"},{"term":"stacks"},{"term":"strings"},{"term":"graphs"},{"term":"Heaps"},{"term":"recursion"},{"term":"C"},{"term":"Microsoft interview questions"},{"term":"divide and conquer"},{"term":"linked list"},{"term":"programming"},{"term":"Queue"},{"term":"binary tree"},{"term":"matrix"},{"term":"undirected graphs"},{"term":"Backtracking"},{"term":"Kth smallest element"},{"term":"LCA"},{"term":"Prune nodes in BST"},{"term":"Quick sort"},{"term":"binary search"},{"term":"bitwise"},{"term":"bitwise operation"},{"term":"duplicate numbers."},{"term":"google interview question"},{"term":"inorder successor"},{"term":"inorder traversal"},{"term":"interrupts"},{"term":"linked list based implementation"},{"term":"lowest common ancestor"},{"term":"min heap"},{"term":"minimum spanning tree"},{"term":"numbers"},{"term":"order statistics"},{"term":"paths in binary search tree"},{"term":"process"},{"term":"queues"},{"term":"semaphore"},{"term":"smallest missing number"},{"term":"sorting"},{"term":"0-1 knapsack"},{"term":"ADT"},{"term":"BFS"},{"term":"BST operations"},{"term":"C programming"},{"term":"C."},{"term":"CFS"},{"term":"Closest element"},{"term":"Completely Fair Scheduler"},{"term":"Count sort"},{"term":"DFs"},{"term":"Delete Binary Search Tree"},{"term":"Eight queens problems"},{"term":"Find duplicate"},{"term":"Find element in rotated array"},{"term":"K smallest elements"},{"term":"KMP"},{"term":"LRU cache"},{"term":"Level order printing of nodes"},{"term":"Life cycle Process"},{"term":"Longest increasing subsequence"},{"term":"Loop in singly linked list"},{"term":"MCDC"},{"term":"Mirror Binary Search Tree"},{"term":"N lines of file"},{"term":"O(1) scheduler"},{"term":"Priority scheduling"},{"term":"Quality related"},{"term":"Replace a node with sum of nodes which are greater than the node"},{"term":"Replace node with sum of children"},{"term":"Replace node with sum of its children"},{"term":"Scheduling"},{"term":"Statement coverage"},{"term":"Trie"},{"term":"Unit testing boundary value analysis"},{"term":"White box testing"},{"term":"XOR"},{"term":"addition of linked list"},{"term":"adjacency list based representation."},{"term":"adjacency matrix representation"},{"term":"algorithms."},{"term":"application of trie."},{"term":"arrangement"},{"term":"array based implementation"},{"term":"array based implementation of queues"},{"term":"asymptotic notation"},{"term":"balance partition"},{"term":"binary search."},{"term":"bottom halves"},{"term":"breadth First traversal"},{"term":"break string into dictionary words"},{"term":"build tree"},{"term":"characters"},{"term":"cheat sheet for complexity analysis"},{"term":"check if tree is binary search tree"},{"term":"code inspection"},{"term":"code walkthrough bugs in code inspection"},{"term":"coin change problem"},{"term":"complexity analysis"},{"term":"condition coverage"},{"term":"conition\/decision coverage"},{"term":"connect nodes at same level"},{"term":"connected components in graphs"},{"term":"conversion"},{"term":"convert BST to DLL"},{"term":"convert binary search tree to DLL"},{"term":"convert binary search tree to doubly linked list."},{"term":"count number of trees with n nodes"},{"term":"count number of words"},{"term":"count sort."},{"term":"covert string to equivalent number"},{"term":"decimal to binary number conversion"},{"term":"deletion of a node"},{"term":"depth first search"},{"term":"depth first traversal"},{"term":"detect cycle in undirected graph"},{"term":"difference"},{"term":"difference between exceptions and interrupts"},{"term":"difference between process and threads"},{"term":"disjoint sets"},{"term":"doubly linked list"},{"term":"duplicate"},{"term":"edit distance"},{"term":"encode a string"},{"term":"event schedule"},{"term":"excel column"},{"term":"exceptions"},{"term":"find K elements in window"},{"term":"find Kth node"},{"term":"find missing numbers"},{"term":"find words in maze"},{"term":"first instance"},{"term":"first instance of 0"},{"term":"first instance of 1"},{"term":"graph traversals."},{"term":"greedy algorithm"},{"term":"heap sort"},{"term":"heapify"},{"term":"if tree is bst"},{"term":"implement queue using stack"},{"term":"implementation"},{"term":"infix to postfix"},{"term":"inorder predecissor"},{"term":"insert in trie"},{"term":"interleaved strings"},{"term":"interrupt handling"},{"term":"kadanes"},{"term":"kernel"},{"term":"kernel API"},{"term":"knapsack problem"},{"term":"kruskal algorithm"},{"term":"last K elements of BST"},{"term":"least recently used cache"},{"term":"linked list merge"},{"term":"longest"},{"term":"longest arithmetic progression"},{"term":"longest common subsequence"},{"term":"matrix chain multiplication"},{"term":"max"},{"term":"max heaps."},{"term":"max operation on stack"},{"term":"max-heap"},{"term":"maze problem"},{"term":"merge"},{"term":"merge  overlapping intervals"},{"term":"merge K arrays"},{"term":"merge point of two linked lists"},{"term":"merge sort"},{"term":"min"},{"term":"min heaps"},{"term":"missing and repeating number"},{"term":"missing elements"},{"term":"missing numbers"},{"term":"move zeroes to end."},{"term":"mutex"},{"term":"mutex Vs semaphore"},{"term":"mutex."},{"term":"next greater element"},{"term":"next smallest element with same bits set"},{"term":"next smallest number with same digits"},{"term":"non-preemptive scheduling"},{"term":"number of bits set"},{"term":"number of instances"},{"term":"orphan process"},{"term":"palindrome"},{"term":"palindrome string"},{"term":"parenthesis matching"},{"term":"peak in array"},{"term":"permutations and combinations"},{"term":"pivot"},{"term":"possible paths in maze"},{"term":"postorder traversal"},{"term":"predecessor"},{"term":"preemptive"},{"term":"preorder traversal"},{"term":"prime factors"},{"term":"prims algorithm"},{"term":"priority queues"},{"term":"process internal representation"},{"term":"process states"},{"term":"processes"},{"term":"programing"},{"term":"ransom note"},{"term":"recursion."},{"term":"recursively reverse a list"},{"term":"remove characters present in other string"},{"term":"remove duplicates"},{"term":"repeating number"},{"term":"replace row and column with 1 in matrix."},{"term":"replace with next greater element"},{"term":"reverse K nodes"},{"term":"reverse a linked list"},{"term":"reverse a string"},{"term":"reverse words in a string"},{"term":"right most bit"},{"term":"right view of tree"},{"term":"rotate an array"},{"term":"rotated array"},{"term":"rotation by 90 degree"},{"term":"schedule"},{"term":"search"},{"term":"search an element in row and column sorted matrix"},{"term":"search element in matrix"},{"term":"set"},{"term":"sign of a number"},{"term":"signal handlers."},{"term":"signals"},{"term":"sliding window"},{"term":"sorted linked list"},{"term":"spinlock"},{"term":"spinlocks"},{"term":"spiral traversal of matrix"},{"term":"stock span problem"},{"term":"string copy"},{"term":"subset sum problem"},{"term":"substring"},{"term":"sum"},{"term":"sum of path equal to given number"},{"term":"t9 dictionary"},{"term":"telephone numbers to words"},{"term":"threads"},{"term":"tokens"},{"term":"tower of hanoi"},{"term":"traps"},{"term":"traversing linked lists"},{"term":"tree traversal with stack"},{"term":"tree traversal without recursion"},{"term":"tries"},{"term":"ugly number"},{"term":"unique rows of boolean matrix"},{"term":"zero sum subarray"},{"term":"zigzag traversal"},{"term":"zombie process"}],"title":{"type":"text","$t":"Algorithms and Me"},"subtitle":{"type":"html","$t":"Its not mine alone... If you have any interesting topic or question with or without solution, please mail me @ jitsceait@gmail.com"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/-\/interview+question?alt=json-in-script\u0026max-results=5"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/search\/label\/interview%20question"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"next","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/-\/interview+question\/-\/interview+question?alt=json-in-script\u0026start-index=6\u0026max-results=5"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"14"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"5"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-3698418121444464286"},"published":{"$t":"2014-04-13T10:52:00.000+05:30"},"updated":{"$t":"2014-05-19T01:31:47.873+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"binary search."},{"scheme":"http://www.blogger.com/atom/ns#","term":"first instance of 0"},{"scheme":"http://www.blogger.com/atom/ns#","term":"first instance of 1"},{"scheme":"http://www.blogger.com/atom/ns#","term":"interview question"},{"scheme":"http://www.blogger.com/atom/ns#","term":"number of instances"}],"title":{"type":"text","$t":"Application of binary search"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EThere are problems which can be easily solved using linear time, can be optimized to log N time complexity using binary search concept. Today we will a problem which applies binary search concept to solve one such problem.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit; text-align: justify;\"\u003EGiven an array containing only 0s and 1s in sorted order. Find the first occurrence of 1 in array.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ESame problem can be asked as find last occurrence of 0.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EOther variant is to find number of ones of zeroes in given array.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit; text-align: justify;\"\u003ELinear time solution is easy. Just go through array and once you hit 1, return the index. Great!\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EBut we need to take advantage of the fact that given array is sorted. So if a given element is not 1, it is guaranteed that no element before it will be 1. So to search first instance of 1, we need to look in right sub array.\u0026nbsp;\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWhat if selected element is 1? That does not guarantee that it will be first instance of 1. But it reduces size of array to look into as first instance will be either at selected index or any index less than it.\u0026nbsp;\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ESo in both the cases we are discarding a part of given input array. Best way to split array is to split it in two parts and that leads us to binary search.\u0026nbsp;\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWe will slightly tweak the binary search algorithm and get our answer.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ESecond variant can be solved in similar manner, only we need to discard different portion of array than what we did in main problem.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EThird variant is extension of the first problem itself. Once we get the first instance of 1, we can subtract that from size of array and get number of occurrence of 1 in array.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"color: #20124d;\"\u003E\u003Cb\u003EFirst instance of a number\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/e2e53e21204c0baca5cd.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"color: #20124d; font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"color: #20124d; font-family: inherit;\"\u003E\u003Cb\u003ELast instance of a number\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/31dcf147898b1ab4ba78.js\"\u003E\u003C\/script\u003E \u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"color: #20124d; font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"color: #20124d; font-family: inherit;\"\u003E\u003Cb\u003ENo of instances of a number\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/dc822885e65216162650.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EComplexity of all above codes is O(log N).\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/3698418121444464286\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/04\/application-of-binary-search.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/3698418121444464286"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/3698418121444464286"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/04\/application-of-binary-search.html","title":"Application of binary search"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-621568251404502777"},"published":{"$t":"2014-03-24T22:41:00.000+05:30"},"updated":{"$t":"2014-05-20T06:45:12.283+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"arrays"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Dynamic Programming"},{"scheme":"http://www.blogger.com/atom/ns#","term":"interview question"}],"title":{"type":"text","$t":"Arrays : Minimum jumps to reach at end"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EToday we will see a problem which can be solved using greedy as well as dynamic algorithm.\u003C\/span\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cb style=\"color: #073763; text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EGiven an array of integers, one can maximum jump a[i] from a given index i. Find minimum number of jumps required to reach at the end of the array.\u003C\/span\u003E\u003C\/b\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"color: #073763; font-family: inherit;\"\u003E\u003Cb\u003E\u003Cbr \/\u003E\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cspan style=\"font-family: inherit;\"\u003EFor example,In following array, minimum number of jumps is 2.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EAt 2 we can either jump 0, 1 or 2 indices at a time. If we jump 2 indices, we would require two more jumps (at 1 and 1) to reach at 4.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-34Wu_MBEqCw\/UzBhrJV-kNI\/AAAAAAAAA3A\/ury99IJWJ4I\/s1600\/Jumps+(1).png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/4.bp.blogspot.com\/-34Wu_MBEqCw\/UzBhrJV-kNI\/AAAAAAAAA3A\/ury99IJWJ4I\/s1600\/Jumps+(1).png\" height=\"84\" width=\"320\" \/\u003E\u003C\/span\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit; font-size: small;\"\u003ESolution with 3 jumps\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cspan style=\"font-family: inherit;\"\u003EHowever if we jump only one index, next time we will reach at the end of the array\u003C\/span\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-pHWd-xQEiRg\/UzBhrPsdNyI\/AAAAAAAAA28\/llgLie8T1m4\/s1600\/Jumps.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/3.bp.blogspot.com\/-pHWd-xQEiRg\/UzBhrPsdNyI\/AAAAAAAAA28\/llgLie8T1m4\/s1600\/Jumps.png\" height=\"93\" width=\"400\" \/\u003E\u003C\/span\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit; font-size: small;\"\u003ESolution with 2 jumps\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit; text-align: justify;\"\u003EWe need to minimize something, that is jump. How can we do that? We take longest jump possible from each index. While taking jump we also take care that which among the possible landing indexes can give us maximum jump ahead. So every time we land, we have selected that index because it will give us maximum jump. Just greedy algorithm.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EMathematically,\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003Efor index i, scan through all indices e from i+1 till e = i + a[i] and calculate a value v = e +a[e]. Take e with maximum v.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003Elet's work out an example:\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EIn above example, for i =0, we check e = 1 and v = 1 (e)+3 (a[e]) =4\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;e = 2 and v = 2 + 1 = 3\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ESo we select e =1.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/debbc9ba7c2d71401fa8.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWhat will be the complexity of the code? It would be O(N).\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ECan we solve this using dynamic programming?\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWhat we need to find minimum jumps to reach Nth index. We can reduce this problem like,\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EIf we find minimum number of jumps for 0 and N-1 and can reach from any of them to Nth item, jumps for Nth index would be one more than that.\u0026nbsp;\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EIf i +a[i] \u0026gt;= N and if Jumps[i] +1 \u0026lt; Jump[N], Jump[N] becomes Jumps[i] +1\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EFor starting index, jumps required would be zero.\u0026nbsp;\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large; text-align: left;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/d3ea6c68a1ccd3f00d1b.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity Analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EComplexity of the algorithm would be O(min(k,N) *N) along space complexity of O(N), where K is maximum jump.\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/621568251404502777\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/03\/arrays-minimum-jumps-to-reach-at-end.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/621568251404502777"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/621568251404502777"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/03\/arrays-minimum-jumps-to-reach-at-end.html","title":"Arrays : Minimum jumps to reach at end"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/4.bp.blogspot.com\/-34Wu_MBEqCw\/UzBhrJV-kNI\/AAAAAAAAA3A\/ury99IJWJ4I\/s72-c\/Jumps+(1).png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-3425778890352864886"},"published":{"$t":"2014-01-14T22:15:00.001+05:30"},"updated":{"$t":"2014-05-24T18:47:49.693+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Dynamic Programming"},{"scheme":"http://www.blogger.com/atom/ns#","term":"interview question"},{"scheme":"http://www.blogger.com/atom/ns#","term":"longest common subsequence"}],"title":{"type":"text","$t":"Dynamic programming : Longest Common Subsequence"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EA subsequence of string is set of all the characters which in a left to right order and not necessarily contiguous. \u0026nbsp;\u003C\/span\u003E\u003Cspan style=\"font-family: inherit;\"\u003EFor example: string ABCDEG has ABC, ADG, EG, BCDEG subsequences.\u003C\/span\u003E\u003C\/div\u003E\u003Cspan style=\"font-family: inherit;\"\u003Ewhereas BDA is not a subsequence of given string.\u003C\/span\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit;\"\u003EGiven two strings X and Y, find longest common subsequence Z.\u003C\/span\u003E\u003C\/div\u003E\u003Cspan style=\"font-family: inherit;\"\u003EFor example\u0026nbsp;\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EX = ABCDSEFGD\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EY = ACFEFXVGAB\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003ELCS Z would be ACEFG.\u003C\/span\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit;\"\u003ECan we divide this problem in sub problems?\u003C\/span\u003E\u003C\/div\u003E\u003Cspan style=\"font-family: inherit;\"\u003ELet's say length of X is N and length of Y as M.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWe start from the end of both strings. Check if X[N] == Y[M].\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EIf yes, over problem now reduces to find the longest common subsequence in X[1...N-1] and Y[1...M-1].\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003EWhat if they are not equal? Then one by one we have to exclude character from string X and Y.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003ESo first we exclude the character from the X. hence problem reduces to X[1...N-1] and Y[1...M].\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EIf we exclude the character from Y, problem reduces to X[1...N] and Y[1...M-1].\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003EWe would take maximum from both the cases. So the recursive relation comes up as\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003Cb\u003EC[i,j] \u0026nbsp;= \u0026nbsp;1 + C[i-1, j-1] if X[i] == Y[j]\u003C\/b\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;= \u0026nbsp; MAX (C[i-1,j], C[i, j-1]) if X[i] != Y[j]\u003C\/span\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;= \u0026nbsp; 0 if i or j is 0\u003C\/span\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003EAbove relation can be easily implemented using recursion construct of programming language.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003EWhen we see that implementation, we notice that there are subproblems which are solved multiple times. To avoid solving those subproblems again and again, we can store values of those subproblems.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EThis gives us a perfect case for application of dynamic programming.\u003C\/span\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/bf07682d2a55a5114805.js\"\u003E\u003C\/script\u003E \u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: inherit; font-size: small;\"\u003EComplexity analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit;\"\u003EAbove implementation has time and space complexity of O(N*N).\u003C\/span\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/3425778890352864886\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/01\/dynamic-programming-longest-common.html#comment-form","title":"2 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/3425778890352864886"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/3425778890352864886"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/01\/dynamic-programming-longest-common.html","title":"Dynamic programming : Longest Common Subsequence"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"thr$total":{"$t":"2"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-9051731370983587595"},"published":{"$t":"2014-01-13T22:29:00.000+05:30"},"updated":{"$t":"2014-05-13T20:40:42.931+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"Dynamic Programming"},{"scheme":"http://www.blogger.com/atom/ns#","term":"interview question"},{"scheme":"http://www.blogger.com/atom/ns#","term":"matrix chain multiplication"}],"title":{"type":"text","$t":"Dynamic Programming  : Matrix chain multiplication"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EMatrix chain multiplication is a typical problem which is used to explain dynamic programming. Approach learnt here can be easily applied to many other problems.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit; text-align: justify;\"\u003EProblem here is, we are given N matrices. Dimensions of each matrix given in an array P where P[i-1] and P[i] denote rows and column respectively of ith matrix. We need to find an order in which these matrices are multiplied, so that total number of scalar multiplications are least.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ESome matrix information\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EMatrix multiplication is associative i.e.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EA* (B*C) = (A*B) *C\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003Ebut not commutative i.e\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EA * (B*C) not equal to A * (C * B)\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003ETo multiply two matrices, they should be compatible i.e. no of columns in first matrix should be equal to number of rows of second matrix.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003ELet's get back to problem.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EEasy way to understand the problem is to say we need to figure out a way to put parenthesis around matrices so that total number of multiplication are least.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003EBrute force way of doing this to find out every possible combination of parenthesis and check which one is minimum.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EThis algorithm is exponential in time and hence of no use for every large input.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003ELet's see if dynamic programming fit in.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWe can see that cost of multiplying matrices Ai to Aj \u0026nbsp;is cost of (Ai to Ak) + (Ak+1 to Aj )+\u0026nbsp;\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E(P[i] * P[k-1] * P[j]).\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EIdea is to find out K such that later expression becomes minimum.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EM[i,j] represents the cost to multiply matrix i to matrix j\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003Cspan style=\"font-family: inherit;\"\u003ELooking at above expression\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cb\u003EM[i,j] \u0026nbsp;= M[i,k] + M[K+1,j]\u003C\/b\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003ESo when we are calculating M[i,j] we should already have M[i,k] and M[k+1,j].\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003EWe also know that M[i,i] = 0 as multiplying a single matrix will be 0.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003ELooking at the requirement to calculate M[i,j], we can say that it depends on the length of the chain. \u003C\/span\u003E\u003Cspan style=\"font-family: inherit;\"\u003ELength of chain from matrix i to matrix j would be i+j-1.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003EWe start with length 2 and go on to solve the table entry for length N. M[1, N] will give us the final cost. Since we need to start at every position for every length,\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003Ethen i + L -1 = j. Also, j\u0026lt;=N; hence i \u0026lt;= N-L+1.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/ddfd2e110c114850f0c6.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003ETime complexity of the code is O(N*N). Also space complexity is O(N*N).\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Ch3 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EReference\u003C\/span\u003E\u003C\/h3\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Ca href=\"http:\/\/www.personal.kent.edu\/~rmuhamma\/Algorithms\/MyAlgorithms\/Dynamic\/chainMatrixMult.htm\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003Ehttp:\/\/www.personal.kent.edu\/~rmuhamma\/Algorithms\/MyAlgorithms\/Dynamic\/chainMatrixMult.htm\u003C\/span\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/9051731370983587595\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/01\/dynamic-programming-matrix-chain.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/9051731370983587595"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/9051731370983587595"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/01\/dynamic-programming-matrix-chain.html","title":"Dynamic Programming  : Matrix chain multiplication"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-1346055229481601974"},"published":{"$t":"2014-01-12T11:38:00.002+05:30"},"updated":{"$t":"2014-05-11T07:02:33.206+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"0-1 knapsack"},{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Dynamic Programming"},{"scheme":"http://www.blogger.com/atom/ns#","term":"interview question"},{"scheme":"http://www.blogger.com/atom/ns#","term":"knapsack problem"}],"title":{"type":"text","$t":"Dynamic programming : 0-1 knapsack problem"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003E0-1 Knapsack problem\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThis is a typical problem which is used to demonstrate application of greedy algorithm as well as dynamic programming. There are cases when applying greedy algorithm does not give optimal solution.\u003C\/div\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThere are many flavors in which this problem can be asked.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E1. A thief enters a museum and want to steal artifacts from there. Every artifact has a weight and value associated with it. Thief carries a knapsack (bag) which can take only a specific weight.\u003C\/div\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: justify;\"\u003EProblem is to find the combination of artifacts thief takes so that he gets maximum value and weight of all the taken artifacts is less the capacity of the bag he has brought.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThief cannot take any artifact partially. Either he takes it or leaves it. Hence the problem is 0-1 knapsack.\u003Cbr \/\u003E\u003Cbr \/\u003E2. Second flavor is : We have N files each having a size say Si. We have a total storage capacity of W bytes. For each file to be store the re-computation cost is Vi. Problem is to store as files on storage that combined size of all files is less than W and their re-computation value is maximum.\u003C\/div\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: justify;\"\u003EWe can either store or leave the file. We cannot store partial file. Hence this is a case of 0-1 knapsack problem.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIn pure mathematics terms:\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThere are N items \u0026lt;I1,I2,................In\u0026gt; each having a weight \u0026lt;w1,w2,...............wn\u0026gt;.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EEach item has a value associated with it \u0026lt;v1,v2, ..........vn\u0026gt;\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cb\u003EGiven a limit W we have to find a subset of K items such that\u0026nbsp;\u003C\/b\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cb\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Sum (w1, w2..... wk) \u0026lt;= W \u0026nbsp;\u0026amp;\u003C\/b\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cb\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Sum (v1,v2,.........vk) is maximum.\u003C\/b\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EBrute force method would try all the subsets of the set of items and see which one gives as the maximum value. This method would be of exponential order.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ECan we do better?\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIf we consider every item, there are two possibilities associated with it.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EFirst, \u003Cb\u003Egiven item is included in the subset which is optimal.\u003C\/b\u003E Then we need to find out all the items in remaining N-1 items which can \u003Cb\u003Eoptimize the sub problem\u003C\/b\u003E for weight W-wk. Value of this item is added to candidate maximum value.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ESecond case is the \u003Cb\u003Eitem is not included\u003C\/b\u003E into the set. In that case, we need to find out items in remaining N-1 items which can \u003Cb style=\"font-family: 'Courier New', Courier, monospace;\"\u003Eoptimize the the original problem\u003C\/b\u003E. Value of this item is not added into candidate maximum value. Inclusion depends on two conditions : 1. Weight of the item is less than the total weight. 2. Inclusion of item increases the value which was already there with K-1 items with W-Wk weight.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EWhen remaining allowed weight is zero (case 1 ) or we have considered all items (case 2) , we have reached the solution.\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EImplementation\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIn implementation, we define a two dimensional array of size N * W.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EElement in this array can be interpreted as for a given value of W \u0026nbsp;\u003Cb\u003E\u003Ci\u003Ew (w\u0026lt;W)\u003C\/i\u003E\u003C\/b\u003E and for a given number of items \u003Cb\u003E\u003Ci\u003Ei (i \u0026lt; N)\u003C\/i\u003E\u003C\/b\u003E, \u0026nbsp; best solution would be value of that element i.e \u003Cb\u003E\u003Ci\u003Earray(I, w)\u003C\/i\u003E\u003C\/b\u003E.\u003Cbr \/\u003EFor i =0 and w=0, all the values will be zero. Hence first column and first row will be filled with all zero values. We would build on top of that.\u003Cbr \/\u003EFor each item in set, we would check for maximum value we can get for weight w.\u003C\/div\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: justify;\"\u003EAs explained in the analysis, based on its two conditions, we include or exclude the item.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EWe can easily keep track of which items are included in optimal structure by keeping boolean two dimensional array. Each element a[i,j] is true if for weight\u003Ci\u003E j ith\u003C\/i\u003E item was included.\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/919256311331670f77f2.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EOne similar problem which can be solved with same approach is minimum number of coins to be used to get change of a particular amount.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EI am skipping the whole analysis and directly pasting the code here.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/96d59c7274411d88fa77.js\"\u003E\u003C\/script\u003E \u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EComplexity of the dynamic programming implementation of the problem is \u003Cb\u003EO(N *W)\u003C\/b\u003E. Space complexity is again \u003Cb\u003EO(N*W)\u003C\/b\u003E. It is thumb rule that we trade space for time in dynamic programming.\u003C\/div\u003E\u003C\/div\u003E\u003Ch3 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: 'Trebuchet MS', sans-serif; font-size: small;\"\u003EReference\u0026nbsp;\u003C\/span\u003E\u003C\/h3\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"background-color: white; color: #006600; font-family: Courier New, Courier, monospace; line-height: 19.4375px; text-decoration: none;\"\u003E\u003Ca href=\"http:\/\/www.es.ele.tue.nl\/education\/5MC10\/Solutions\/knapsack.pdf\" style=\"background-color: white; color: #006600; line-height: 19.4375px; text-decoration: none;\"\u003Ehttp:\/\/www.es.ele.tue.nl\/education\/5MC10\/Solutions\/knapsack.pdf\u003C\/a\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/1346055229481601974\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/01\/dynamic-problem-0-1-knapsack-problem.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/1346055229481601974"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/1346055229481601974"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/01\/dynamic-problem-0-1-knapsack-problem.html","title":"Dynamic programming : 0-1 knapsack problem"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"thr$total":{"$t":"0"}}]}});