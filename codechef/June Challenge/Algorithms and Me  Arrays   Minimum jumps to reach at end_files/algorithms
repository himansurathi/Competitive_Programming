// API callback
related_results_labels_thumbs({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170"},"updated":{"$t":"2014-06-15T11:11:58.181+05:30"},"category":[{"term":"algorithms"},{"term":"binary search tree"},{"term":"Dynamic Programming"},{"term":"arrays"},{"term":"interview question"},{"term":"Operating Systems"},{"term":"stacks"},{"term":"strings"},{"term":"graphs"},{"term":"Heaps"},{"term":"recursion"},{"term":"C"},{"term":"Microsoft interview questions"},{"term":"divide and conquer"},{"term":"linked list"},{"term":"programming"},{"term":"Queue"},{"term":"binary tree"},{"term":"matrix"},{"term":"undirected graphs"},{"term":"Backtracking"},{"term":"Kth smallest element"},{"term":"LCA"},{"term":"Prune nodes in BST"},{"term":"Quick sort"},{"term":"binary search"},{"term":"bitwise"},{"term":"bitwise operation"},{"term":"duplicate numbers."},{"term":"google interview question"},{"term":"inorder successor"},{"term":"inorder traversal"},{"term":"interrupts"},{"term":"linked list based implementation"},{"term":"lowest common ancestor"},{"term":"min heap"},{"term":"minimum spanning tree"},{"term":"numbers"},{"term":"order statistics"},{"term":"paths in binary search tree"},{"term":"process"},{"term":"queues"},{"term":"semaphore"},{"term":"smallest missing number"},{"term":"sorting"},{"term":"0-1 knapsack"},{"term":"ADT"},{"term":"BFS"},{"term":"BST operations"},{"term":"C programming"},{"term":"C."},{"term":"CFS"},{"term":"Closest element"},{"term":"Completely Fair Scheduler"},{"term":"Count sort"},{"term":"DFs"},{"term":"Delete Binary Search Tree"},{"term":"Eight queens problems"},{"term":"Find duplicate"},{"term":"Find element in rotated array"},{"term":"K smallest elements"},{"term":"KMP"},{"term":"LRU cache"},{"term":"Level order printing of nodes"},{"term":"Life cycle Process"},{"term":"Longest increasing subsequence"},{"term":"Loop in singly linked list"},{"term":"MCDC"},{"term":"Mirror Binary Search Tree"},{"term":"N lines of file"},{"term":"O(1) scheduler"},{"term":"Priority scheduling"},{"term":"Quality related"},{"term":"Replace a node with sum of nodes which are greater than the node"},{"term":"Replace node with sum of children"},{"term":"Replace node with sum of its children"},{"term":"Scheduling"},{"term":"Statement coverage"},{"term":"Trie"},{"term":"Unit testing boundary value analysis"},{"term":"White box testing"},{"term":"XOR"},{"term":"addition of linked list"},{"term":"adjacency list based representation."},{"term":"adjacency matrix representation"},{"term":"algorithms."},{"term":"application of trie."},{"term":"arrangement"},{"term":"array based implementation"},{"term":"array based implementation of queues"},{"term":"asymptotic notation"},{"term":"balance partition"},{"term":"binary search."},{"term":"bottom halves"},{"term":"breadth First traversal"},{"term":"break string into dictionary words"},{"term":"build tree"},{"term":"characters"},{"term":"cheat sheet for complexity analysis"},{"term":"check if tree is binary search tree"},{"term":"code inspection"},{"term":"code walkthrough bugs in code inspection"},{"term":"coin change problem"},{"term":"complexity analysis"},{"term":"condition coverage"},{"term":"conition\/decision coverage"},{"term":"connect nodes at same level"},{"term":"connected components in graphs"},{"term":"conversion"},{"term":"convert BST to DLL"},{"term":"convert binary search tree to DLL"},{"term":"convert binary search tree to doubly linked list."},{"term":"count number of trees with n nodes"},{"term":"count number of words"},{"term":"count sort."},{"term":"covert string to equivalent number"},{"term":"decimal to binary number conversion"},{"term":"deletion of a node"},{"term":"depth first search"},{"term":"depth first traversal"},{"term":"detect cycle in undirected graph"},{"term":"difference"},{"term":"difference between exceptions and interrupts"},{"term":"difference between process and threads"},{"term":"disjoint sets"},{"term":"doubly linked list"},{"term":"duplicate"},{"term":"edit distance"},{"term":"encode a string"},{"term":"event schedule"},{"term":"excel column"},{"term":"exceptions"},{"term":"find K elements in window"},{"term":"find Kth node"},{"term":"find missing numbers"},{"term":"find words in maze"},{"term":"first instance"},{"term":"first instance of 0"},{"term":"first instance of 1"},{"term":"graph traversals."},{"term":"greedy algorithm"},{"term":"heap sort"},{"term":"heapify"},{"term":"if tree is bst"},{"term":"implement queue using stack"},{"term":"implementation"},{"term":"infix to postfix"},{"term":"inorder predecissor"},{"term":"insert in trie"},{"term":"interleaved strings"},{"term":"interrupt handling"},{"term":"kadanes"},{"term":"kernel"},{"term":"kernel API"},{"term":"knapsack problem"},{"term":"kruskal algorithm"},{"term":"last K elements of BST"},{"term":"least recently used cache"},{"term":"linked list merge"},{"term":"longest"},{"term":"longest arithmetic progression"},{"term":"longest common subsequence"},{"term":"matrix chain multiplication"},{"term":"max"},{"term":"max heaps."},{"term":"max operation on stack"},{"term":"max-heap"},{"term":"maze problem"},{"term":"merge"},{"term":"merge  overlapping intervals"},{"term":"merge K arrays"},{"term":"merge point of two linked lists"},{"term":"merge sort"},{"term":"min"},{"term":"min heaps"},{"term":"missing and repeating number"},{"term":"missing elements"},{"term":"missing numbers"},{"term":"move zeroes to end."},{"term":"mutex"},{"term":"mutex Vs semaphore"},{"term":"mutex."},{"term":"next greater element"},{"term":"next smallest element with same bits set"},{"term":"next smallest number with same digits"},{"term":"non-preemptive scheduling"},{"term":"number of bits set"},{"term":"number of instances"},{"term":"orphan process"},{"term":"palindrome"},{"term":"palindrome string"},{"term":"parenthesis matching"},{"term":"peak in array"},{"term":"permutations and combinations"},{"term":"pivot"},{"term":"possible paths in maze"},{"term":"postorder traversal"},{"term":"predecessor"},{"term":"preemptive"},{"term":"preorder traversal"},{"term":"prime factors"},{"term":"prims algorithm"},{"term":"priority queues"},{"term":"process internal representation"},{"term":"process states"},{"term":"processes"},{"term":"programing"},{"term":"ransom note"},{"term":"recursion."},{"term":"recursively reverse a list"},{"term":"remove characters present in other string"},{"term":"remove duplicates"},{"term":"repeating number"},{"term":"replace row and column with 1 in matrix."},{"term":"replace with next greater element"},{"term":"reverse K nodes"},{"term":"reverse a linked list"},{"term":"reverse a string"},{"term":"reverse words in a string"},{"term":"right most bit"},{"term":"right view of tree"},{"term":"rotate an array"},{"term":"rotated array"},{"term":"rotation by 90 degree"},{"term":"schedule"},{"term":"search"},{"term":"search an element in row and column sorted matrix"},{"term":"search element in matrix"},{"term":"set"},{"term":"sign of a number"},{"term":"signal handlers."},{"term":"signals"},{"term":"sliding window"},{"term":"sorted linked list"},{"term":"spinlock"},{"term":"spinlocks"},{"term":"spiral traversal of matrix"},{"term":"stock span problem"},{"term":"string copy"},{"term":"subset sum problem"},{"term":"substring"},{"term":"sum"},{"term":"sum of path equal to given number"},{"term":"t9 dictionary"},{"term":"telephone numbers to words"},{"term":"threads"},{"term":"tokens"},{"term":"tower of hanoi"},{"term":"traps"},{"term":"traversing linked lists"},{"term":"tree traversal with stack"},{"term":"tree traversal without recursion"},{"term":"tries"},{"term":"ugly number"},{"term":"unique rows of boolean matrix"},{"term":"zero sum subarray"},{"term":"zigzag traversal"},{"term":"zombie process"}],"title":{"type":"text","$t":"Algorithms and Me"},"subtitle":{"type":"html","$t":"Its not mine alone... If you have any interesting topic or question with or without solution, please mail me @ jitsceait@gmail.com"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/-\/algorithms?alt=json-in-script\u0026max-results=5"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/search\/label\/algorithms"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"next","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/-\/algorithms\/-\/algorithms?alt=json-in-script\u0026start-index=6\u0026max-results=5"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"95"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"5"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-2089678223163983963"},"published":{"$t":"2014-06-15T11:03:00.000+05:30"},"updated":{"$t":"2014-06-15T11:11:58.204+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"graphs"},{"scheme":"http://www.blogger.com/atom/ns#","term":"minimum spanning tree"},{"scheme":"http://www.blogger.com/atom/ns#","term":"prims algorithm"}],"title":{"type":"text","$t":"Graphs : Minimum Spanning Tree Prim's Algorithm"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EPrim's Algorithm for Minimum Spanning Tree\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv style=\"text-align: justify;\"\u003ESecond mostly used algorithm to find minimum spanning tree is Prim's algorithm.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EBasic idea is to have two sets of nodes of graph, one which are already included into minimum spanning tree and other which are not included yet. Now find an edge with least weight which connects any node or vertex in set 1 to any vertex in set 2. Such an edge is commonly called as cut.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ELet two sets be A which includes all vertices of graph which are included in MST and V is set which contains all vertices which are not included in MST yet. Let S be set of all vertices of a graph.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ERelationship between these three would be\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cb\u003EA = S\\V\u003C\/b\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ETo start with A will be empty and V will be equal to S. Start with one vertex and add it to A. Also cost of all nodes initially is INFINITE. Once we add the vertex to A, update the cost of all neighbor vertex based on cost to reach vertex added in A and cost of edge between this vertex and neighboring vertex.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ERemove the vertex from V.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EOnce update is done, select the edge which is minimum and connects one vertex in A and other in V, more simply said does not form a cycle. (If both the ends of an edge are in same component of the graph there are bound form a cycle.)\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ELet's see the algorithm and then we will see how can we implement it.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Col style=\"text-align: justify;\"\u003E\u003Cli\u003EInitialize cost of each vertex with INFINITE. Except from the first vertex where we will start.\u003C\/li\u003E\u003Cli\u003EFor each neighbor, if cost of reaching neighbor node from current vertex is less than current cost, update the cost of neighboring node.\u003C\/li\u003E\u003Cli\u003ESelect the minimum cost neighbor vertex among these vertex and see if edge forms a cycle.\u003C\/li\u003E\u003Cli\u003EIf it forms a cycle take another vertex till we considered every neighboring vertices.\u003C\/li\u003E\u003Cli\u003EIf it does not form cycle, add it to MST and go to step 2.\u003C\/li\u003E\u003Cli\u003ERepeat all above steps till all the vertices are not included in tree.\u003C\/li\u003E\u003C\/ol\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ESee the working of algorithm.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ctable cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-rEOtBi71nmw\/U50cD0DIjTI\/AAAAAAAABGI\/wA9XMD8KjwU\/s1600\/prims+(1).png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/4.bp.blogspot.com\/-rEOtBi71nmw\/U50cD0DIjTI\/AAAAAAAABGI\/wA9XMD8KjwU\/s1600\/prims+(1).png\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"font-size: 13.333333969116211px;\"\u003E\u003Cbr \/\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ctable cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-8P_80NUZkC4\/U50cDo30AwI\/AAAAAAAABGE\/xDfV0mT8l74\/s1600\/prims-2.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/2.bp.blogspot.com\/-8P_80NUZkC4\/U50cDo30AwI\/AAAAAAAABGE\/xDfV0mT8l74\/s1600\/prims-2.png\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"font-size: 13.333333969116211px;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-size: small;\"\u003EWorking of Prim's algorithm\u003C\/span\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cdiv style=\"text-align: justify;\"\u003ELet's see the implementation now.\u0026nbsp;\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EFirst thing we need to do is to keep track of two sets. We can do so by keeping track of each node in MST. Create an array and every time we add an node in MST, mark it as added. While considering any edge in future, just check if MST[i] is true, if it is then node is already added in MST and should not be added again.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ESecond thing is to keep track of distance of each node. Initially all nodes are at INFINITE distance.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EAs we traverse the graph, update each node's distance from current node. Keep an array of integers initialized with INFINITE and every time we add a node in MST, update distance of neighboring nodes based on cost of edge from current node to them.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ELast step is to find the minimum cost edge between two sets. We can scan through the distance array which we discussed in above paragraph and get a node which has least cost and not already in MST (using the array values in discussed in paragraph 1)\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EFinding minimum can be implemented using min heap or priority queues, that would reduce the complexity of overall algorithm.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EAdd edge logic can be found at \u003Ca href=\"http:\/\/algorithmsandme.blogspot.in\/2014\/06\/graphs-minimum-spanning-tree-kruskal.html#.U50xp_mSyAg\"\u003EKruskal algorithm\u003C\/a\u003E\u003Cbr \/\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/18a6936b478d04cb5d48.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity Analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit;\"\u003EComplexity of above code is O(V^2).\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/2089678223163983963\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/prims-algorithm-for-minimum-spanning.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/2089678223163983963"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/2089678223163983963"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/prims-algorithm-for-minimum-spanning.html","title":"Graphs : Minimum Spanning Tree Prim's Algorithm"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/4.bp.blogspot.com\/-rEOtBi71nmw\/U50cD0DIjTI\/AAAAAAAABGI\/wA9XMD8KjwU\/s72-c\/prims+(1).png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-6851037436986291542"},"published":{"$t":"2014-06-14T16:39:00.001+05:30"},"updated":{"$t":"2014-06-15T11:04:40.135+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"graphs"},{"scheme":"http://www.blogger.com/atom/ns#","term":"kruskal algorithm"},{"scheme":"http://www.blogger.com/atom/ns#","term":"minimum spanning tree"},{"scheme":"http://www.blogger.com/atom/ns#","term":"undirected graphs"}],"title":{"type":"text","$t":"Graphs : Minimum Spanning Tree : Kruskal Algorithms"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"text-align: justify;\"\u003EGiven a weighted connected undirected graph, find minimum spanning tree in that graph.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"text-align: justify;\"\u003ELet's first understand what is spanning tree. Spanning tree is tree which connects each vertex of the graph. When graph is weighted i.e each edge of the graph has some weight to move from one node to another, spanning tree with minimum cost is called as minimum spanning tree. If all the edges contain distinct weights, there will be unique minimum spanning tree for that graph, however, if two edges can have same weight then there can be more than one minimum spanning tree for given tree.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"text-align: justify;\"\u003EFor graph shown below, second figure shows spanning trees for that graph.\u003C\/span\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-xqXEWPrRN-I\/U5wsnaWxDFI\/AAAAAAAABFs\/tU9Q1KiiFi0\/s1600\/graph+(1).png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/3.bp.blogspot.com\/-xqXEWPrRN-I\/U5wsnaWxDFI\/AAAAAAAABFs\/tU9Q1KiiFi0\/s1600\/graph+(1).png\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-size: small;\"\u003EGiven undirected graph\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-TqjixooQwdI\/U5wsnpiH84I\/AAAAAAAABFw\/G4KZ9eDg8-0\/s1600\/graph+(2).png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/2.bp.blogspot.com\/-TqjixooQwdI\/U5wsnpiH84I\/AAAAAAAABFw\/G4KZ9eDg8-0\/s1600\/graph+(2).png\" height=\"432\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-size: small;\"\u003ESpanning trees for given graph\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cspan style=\"text-align: justify;\"\u003ELet's see some of the applications of minimum spanning trees:\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E1 . Broadcast tree preparation for broadcasting in internet. It is implemented using spanning tree protocol.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E2. \u0026nbsp;Preparing telecommunication networks, water supply networks etc.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThere are two widely used algorithms to find minimum spanning tree for a graph, both based on greedy algorithm. Basic idea of greedy algorithm is that at every step we chose the option which gives us maximum profit at that step without worrying about future steps.\u0026nbsp;\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ELet's see these greedy algorithms.\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003E1. Kruskal's algorithm\u003C\/span\u003E\u003C\/b\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"text-align: justify;\"\u003EBasic idea is that we take each edge one by one in increasing order of weight. For each edge check if it makes a cycle in existing tree. If it does not add it to minimum spanning tree formed till now. If it forms a cycle discard the edge. Repeat above steps till all nodes are added in tree. Resulting tree will be minimum spanning tree.\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003C\/div\u003E\u003Col\u003E\u003Cli\u003ESort all edges based on weights\u003C\/li\u003E\u003Cli\u003EStart with minimum cost edge. Add it to T.\u003C\/li\u003E\u003Cli\u003EFor each edge in graph, repeat following steps.\u003C\/li\u003E\u003Cli\u003EIf current edge forms a cycle, discard the edge.\u003C\/li\u003E\u003Cli\u003EIf current edge does not form a cycle, add it to T.\u003C\/li\u003E\u003C\/ol\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u0026nbsp;\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/424f9b6b1c9c2a83eafc.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity Analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv style=\"text-align: justify;\"\u003EComplexity of the above algorithm is dominated by the sorting which takes O(E log E) where E is number of edges. To detect whether edge forms a cycle or not, we can use Union and Find method.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003C\/tbody\u003E\u003C\/table\u003EPrim's Algorithm is discussed here : \u0026nbsp;\u003Cspan style=\"font-family: inherit; text-align: left;\"\u003E\u003Ca href=\"http:\/\/algorithmsandme.blogspot.in\/2014\/06\/graphs-minimum-spanning-tree-prims.html#.U50v8_mSyAg\" style=\"text-align: left;\"\u003EGraphs : Minimum Spanning Tree Prim's Algorithm\u003C\/a\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/6851037436986291542\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/graphs-minimum-spanning-tree-kruskal.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/6851037436986291542"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/6851037436986291542"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/graphs-minimum-spanning-tree-kruskal.html","title":"Graphs : Minimum Spanning Tree : Kruskal Algorithms"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/3.bp.blogspot.com\/-xqXEWPrRN-I\/U5wsnaWxDFI\/AAAAAAAABFs\/tU9Q1KiiFi0\/s72-c\/graph+(1).png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-5795512998044368093"},"published":{"$t":"2014-06-12T21:56:00.000+05:30"},"updated":{"$t":"2014-06-13T00:13:37.266+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"detect cycle in undirected graph"},{"scheme":"http://www.blogger.com/atom/ns#","term":"graphs"},{"scheme":"http://www.blogger.com/atom/ns#","term":"undirected graphs"}],"title":{"type":"text","$t":"Graphs : Detecting cycle in undirected graph"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003EGiven an undirected graph, check if there is a cycle in it or not.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EFor example below graph has cycles as 3-\u0026gt;6-\u0026gt;5-\u0026gt;3, 1-\u0026gt;4-\u0026gt;3-\u0026gt;6-\u0026gt;2-\u0026gt;1\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/-vynFrk5TmFY\/U5nUMhAbwCI\/AAAAAAAABFA\/aIlXAY-kY-I\/s1600\/cycle_graph.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/1.bp.blogspot.com\/-vynFrk5TmFY\/U5nUMhAbwCI\/AAAAAAAABFA\/aIlXAY-kY-I\/s1600\/cycle_graph.png\" height=\"235\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-size: small;\"\u003EGraph with cycle\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003ESimple definition of a cycle in graph would be : If while traversing graph, we reach at a node which we have already traversed to reach current node, then there is a cycle in graph.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EHow can we detect the above condition? It's simple application of Depth First Search.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EDo depth first traversal of a graph, if we detect any back edge while traversing, then there is a cycle. Back edge in a graph is an edge which if from a decedent to ancestor. For example in above graph, edge from 2 to 1 is a back edge.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EWhile depth first traversing a graph, keep track of the nodes which are on the stack at present. If there is an edge from current node to any one of the node which is on recursion stack, we say cycle is detected.\u0026nbsp;\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/6d1ca9be128b2baa3c87.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity Analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003EComplexity of above code is equal to complexity of DFS which is O(V+E) where V is number of vertices and E is number of edges.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ESecond Method Using disjoint sets\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003EAnother method to detect cycle in an undirected graph is Union-Find method. To understand that method, we need to first understand a data structure called disjoint-set data structure.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIt is a data structure, which keeps track of all the sets of elements partitioned in disjoint subset. Subsets are said to be disjoint if there is intersection between them is NULL. For example set {1,2,3 } and {4,5,6 } are disjoint sets, but {1,2,3 } and {1,3,5} are not.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EAnother important thing about disjoint set is that every set is represented by a member of that set called as representative.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThere are some operations which are useful on this data structure:\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cb\u003E1. Make Set :\u0026nbsp;\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003Ecreates a new set with one element {x}\u003C\/span\u003E\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cb\u003E2. Union : Merges two sets containing X and Y and destroys the original sets.\u003C\/b\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cb\u003E3. Find : Returns the representative of the set which element belongs to.\u003C\/b\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003ELet's take an example and see how it can be used to detect cycle in graph.\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003EPrinciple here is that if two nodes forming an edge are in same disjoint set, then there is a cycle in graph.\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003EMake set will create a set with each node with representative element as -1, which means there is only one element in each disjoint subset. Now one by one we check each edge and update our data structure accordingly. For edge 0-1, both are in different subsets, we need to merge them together. So sets become {0,1} and {2}. Representative of set {0,1} be {1}. Now consider another edge, 1-2. Node 1 belongs to set represented by 1 and 2 belongs to set represented by -1. Both are different subsets, we will merge them together. So set becomes {0,1,2} represented by 2.\u0026nbsp;\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003ENow take edge 0-2, where 0 and 2 are in set which is represented by 2, hence there is a cycle in the graph.\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003EHow can we implement it? There are two ways to do so. One is to have a linked list of all elements of a set for each set. Each element in turn points to the representative element. So find operation will be O(1), however union or merge operation will be O(N) as we need to modify representative element in each element of the list.\u003C\/span\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/span\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EOther method is to use array. This\u0026nbsp;\u003C\/span\u003Eauxiliary array stores the parent of node i at array[i]. Initially all elements in array are -1. Now whenever we merge two set, we update the corresponding index with representative element.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-ebR4UuRzYzw\/U5nR3l5AVqI\/AAAAAAAABE0\/NcFmgHYd864\/s1600\/disjoint+set.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/4.bp.blogspot.com\/-ebR4UuRzYzw\/U5nR3l5AVqI\/AAAAAAAABE0\/NcFmgHYd864\/s1600\/disjoint+set.png\" height=\"299\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cspan style=\"color: #333333; text-align: -webkit-center;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/span\u003E\u003Cb\u003EFind operation\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre style=\"background-color: #f9f9f9; border: 1px solid rgb(221, 221, 221); font-family: monospace, Courier; font-size: 14px; line-height: 1.3em; padding: 1em; text-align: start;\"\u003E\u003Cb style=\"background-color: transparent; font-size: 14px; line-height: 1.3em;\"\u003Efunction\u003C\/b\u003E\u003Cspan style=\"font-size: 14px; line-height: 1.3em;\"\u003E\u0026nbsp;\u003C\/span\u003E\u003Ci style=\"background-color: transparent; font-size: 14px; line-height: 1.3em;\"\u003EFind\u003C\/i\u003E\u003Cspan style=\"font-size: 14px; line-height: 1.3em;\"\u003E(x)\u003C\/span\u003E\u003C\/pre\u003E\u003Cpre style=\"background-color: #f9f9f9; border: 1px solid rgb(221, 221, 221); font-family: monospace, Courier; font-size: 14px; line-height: 1.3em; padding: 1em; text-align: start;\"\u003E   if x.parent == -1\u003Cbr \/\u003E        return x\u003Cbr \/\u003E     else\u003Cbr \/\u003E        return \u003Ci\u003EFind\u003C\/i\u003E(x.parent)\u003C\/pre\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cspan style=\"color: #333333;\"\u003E\u003Cb\u003E\u003Cbr \/\u003E\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cspan style=\"color: #333333;\"\u003E\u003Cb\u003EUnion Operation\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cpre style=\"background-color: #f9f9f9; border: 1px solid rgb(221, 221, 221); font-family: monospace, Courier; font-size: 14px; line-height: 1.3em; padding: 1em; text-align: start;\"\u003E \u003Cb\u003Efunction\u003C\/b\u003E \u003Ci\u003EUnion\u003C\/i\u003E(x, y)\u003Cbr \/\u003E     xRoot := \u003Ci\u003EFind\u003C\/i\u003E(x)\u003Cbr \/\u003E     yRoot := \u003Ci\u003EFind\u003C\/i\u003E(y)\u003Cbr \/\u003E     xRoot.parent := yRoot\u003C\/pre\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003Cb\u003EMake set operation\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre style=\"background-color: #f9f9f9; border: 1px solid rgb(221, 221, 221); font-family: monospace, Courier; font-size: 14px; line-height: 1.3em; padding: 1em; text-align: start;\"\u003E\u003Cb\u003Efunction\u003C\/b\u003E \u003Ci\u003EMakeSet\u003C\/i\u003E(x)\u003Cbr \/\u003E     x.parent := -1\u003C\/pre\u003E\u003Ch2\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace;\"\u003E\u003Cb\u003Eadd_edge definition can be found at post : \u003Ca href=\"http:\/\/algorithmsandme.blogspot.in\/2014\/05\/graphs-graph-is-collection-of-edges-e.html\"\u003EGraphs Basics and representation\u003C\/a\u003E\u003C\/b\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/d69955183b5187456b5b.js\"\u003E\u003C\/script\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/5795512998044368093\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/graphs-detecting-cycle-in-undirected.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/5795512998044368093"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/5795512998044368093"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/graphs-detecting-cycle-in-undirected.html","title":"Graphs : Detecting cycle in undirected graph"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/1.bp.blogspot.com\/-vynFrk5TmFY\/U5nUMhAbwCI\/AAAAAAAABFA\/aIlXAY-kY-I\/s72-c\/cycle_graph.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-791284559679663317"},"published":{"$t":"2014-06-11T09:11:00.000+05:30"},"updated":{"$t":"2014-06-11T09:13:46.653+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"next greater element"},{"scheme":"http://www.blogger.com/atom/ns#","term":"replace with next greater element"},{"scheme":"http://www.blogger.com/atom/ns#","term":"stacks"}],"title":{"type":"text","$t":"Stacks : Next greater number for every element"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EProblem statement\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003EGiven an array of integers, for each a[i] element print a[j] such that a[j] \u0026gt; a[i] and j\u0026gt;i. Also j should be as close to i as possible. For the rightmost element, value will be -1. If for any i if there is no such j, then result for that too will be -1. In simple terms, we need to print nearest greater number for each element in given array.\u003C\/div\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EAnalysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003ESimple brute force method would be to scan array in two loops. For each element in array, scan remaining right side elements and find out the greater number. Complexity of such code will be O(N^2).\u003C\/div\u003EHow can we do better?\u003Cbr \/\u003EIf we keep track of all the numbers for which we have yet not encountered a greater number, we keep improve. Idea is that whenever we examine a number, we check if there are elements which are already visited in array and yet there is no greater number assigned to them. If there are such elements, we check if current element is greater than them. If yes, then for all those numbers which are less than current element, next greater element will be current number.\u003Cbr \/\u003E\u003Cbr \/\u003ETo keep track of the numbers which have yet not assigned greater number, we can use stack. Steps are simple.\u003Cbr \/\u003E\u003Col style=\"text-align: left;\"\u003E\u003Cli\u003EIf stack is empty, push the element on to stack.\u003C\/li\u003E\u003Cli\u003EIf stack is not empty, pop all elements from the stack which less than current element.\u003C\/li\u003E\u003Cli\u003EPrint these numbers paired with current number.\u003C\/li\u003E\u003Cli\u003EIf top of the stack is not less than current element or stack is empty, push the current element.(All the elements present in stack will be greater than current element why?)\u003C\/li\u003E\u003Cli\u003EAfter scanning all elements in array, print all elements in stack paired with -1 as there is no greater element on right side of these elements.\u003C\/li\u003E\u003C\/ol\u003ELet's workout an example:\u003Cbr \/\u003EA \u0026nbsp;=\u0026nbsp;\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E{\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E5\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E,\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E6\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E,\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E3\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E,\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E35\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E,\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E23\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E,\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E6\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E,\u003C\/span\u003E\u003Cspan class=\"mi\" style=\"background-color: white; box-sizing: border-box; color: #009999; line-height: 16.799999237060547px; white-space: pre;\"\u003E8\u003C\/span\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E}\u003C\/span\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E\u003Cb\u003EOutput should be {(5,6), (6,35), (3,35), (6,8), (8, -1), (23, -1), (35, -1)}\u003C\/b\u003E\u003C\/span\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"font-family: inherit;\"\u003E\u003Cspan class=\"p\" style=\"background-color: white; box-sizing: border-box; color: #333333; line-height: 16.799999237060547px; white-space: pre;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-E9fmhaJFYH8\/U5fO4X6UkqI\/AAAAAAAABEg\/G7Yh2ufsWYU\/s1600\/greatr.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/2.bp.blogspot.com\/-E9fmhaJFYH8\/U5fO4X6UkqI\/AAAAAAAABEg\/G7Yh2ufsWYU\/s1600\/greatr.png\" height=\"640\" width=\"568\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: 'Courier New', Courier, monospace; font-size: large;\"\u003ECode\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/6a08775b7fd0ad5cd83f.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: inherit;\"\u003EStack implementation can be referred in this post : \u003Ca href=\"http:\/\/algorithmsandme.blogspot.in\/2014\/01\/stacks-of-stacks.html#.U5fQSPmSyAg\"\u003EStack implementation\u003C\/a\u003E\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: left;\"\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity Analysis\u003C\/span\u003E\u003C\/h2\u003E\u003Cdiv\u003EComplexity of above code will be O(N) with extra space complexity of O(N) for stack.\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/791284559679663317\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/stacks-next-greater-number-for-every.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/791284559679663317"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/791284559679663317"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/stacks-next-greater-number-for-every.html","title":"Stacks : Next greater number for every element"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/2.bp.blogspot.com\/-E9fmhaJFYH8\/U5fO4X6UkqI\/AAAAAAAABEg\/G7Yh2ufsWYU\/s72-c\/greatr.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2585955070696911170.post-3866324507436665576"},"published":{"$t":"2014-06-08T21:19:00.000+05:30"},"updated":{"$t":"2014-06-13T21:47:46.772+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"BFS"},{"scheme":"http://www.blogger.com/atom/ns#","term":"breadth First traversal"},{"scheme":"http://www.blogger.com/atom/ns#","term":"depth first traversal"},{"scheme":"http://www.blogger.com/atom/ns#","term":"DFs"},{"scheme":"http://www.blogger.com/atom/ns#","term":"graph traversals."},{"scheme":"http://www.blogger.com/atom/ns#","term":"graphs"}],"title":{"type":"text","$t":"Graph Traversals"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: justify;\"\u003EThere are two kinds of traversals which are usually done on graph.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E1. Depth First traversal, commonly called DFS.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E2. Breadth First traversal, commonly called as BFS.\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EDepth First Traversal (DFS)\u003C\/span\u003E\u003C\/b\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EDepth First is a technique in which we explore the graph depth wise, that is we move down the graph from one node to another till the time we are out of all unexplored edges at a node, once we reach that condition, we backtrack and move to node one before and so on.\u003Cbr \/\u003E\u003Cbr \/\u003EIn this traversal, we start with a node S, and mark it as visited. Now S be our current node u.\u0026nbsp;\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EMove to v where there is an edge (u,v).\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIf v is already visited, we move back to u.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIf v is not visited, mark v as visited and make v as current node and repeated above steps.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EAt some point all the edges at u will lead to already visited node, then we drop u and move to node which was visited before u. (remember we need to keep track of that :))\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EOnce with this backtracking, we reach at start node S again and there is no edge to be explored at S, that would be the end of traversal.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ctable cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-AIXNeZhb6rU\/U5RQMfks1lI\/AAAAAAAABEE\/bYlshSXHAOM\/s1600\/graph-traversal+(1).png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/4.bp.blogspot.com\/-AIXNeZhb6rU\/U5RQMfks1lI\/AAAAAAAABEE\/bYlshSXHAOM\/s1600\/graph-traversal+(1).png\" height=\"640\" width=\"548\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-size: small;\"\u003EDepth First traversal of a graph\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cb\u003EApplications of DFS\u003C\/b\u003E\u003Cbr \/\u003E\u003Col\u003E\u003Cli\u003EMinimum spanning tree\u003C\/li\u003E\u003Cli\u003ETo check if graph has a cycle.\u003C\/li\u003E\u003Cli\u003ETopological sorting\u003C\/li\u003E\u003Cli\u003ETo find strongly connected components of graph\u003C\/li\u003E\u003Cli\u003ETo find bridges in graph\u003C\/li\u003E\u003C\/ol\u003E\u003Cb\u003ECode\u003C\/b\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/76426e0bd0123ae13fea.js\"\u003E\u003C\/script\u003E\u003Cb\u003EGraph code\u003C\/b\u003E\u003C\/div\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/f20ba8a167f1e6b9c088.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit; font-size: small;\"\u003EDriver code\u003C\/span\u003E\u003C\/b\u003E\u003C\/h2\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/45508e2dd6d76bb591fb.js\"\u003E\u003C\/script\u003E \u003Cbr \/\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cspan style=\"font-family: inherit; font-size: small; font-weight: normal;\"\u003EAbove code will work only if there graph has only one connected component. If there are multiple connected components we need to do dfs function call for every node, we will see that part once we do connected component problem of graph.\u003C\/span\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: justify;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EBreadth First Search\u003C\/span\u003E\u003C\/b\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: justify;\"\u003EIn this traversal, we start with node S as first node. Let S be node u. Mark it as visited\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003ENow, first visit all the nodes which are at one edge distance from u.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003EOnce all nodes are visited, make each neighbor node as u one by one and repeat above steps till the time we have some unexplored edges.\u003C\/div\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ctable cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/-oJxH8lY-lOI\/U5RRlUYfqBI\/AAAAAAAABEQ\/HA5LU8LuD4k\/s1600\/Graph-bfs.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" src=\"http:\/\/1.bp.blogspot.com\/-oJxH8lY-lOI\/U5RRlUYfqBI\/AAAAAAAABEQ\/HA5LU8LuD4k\/s1600\/Graph-bfs.png\" height=\"614\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-size: small;\"\u003EBreadth First Traversal of graph\u003C\/span\u003E\u003C\/b\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cdiv style=\"text-align: justify;\"\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit;\"\u003EApplications of BFS\u003C\/span\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Col\u003E\u003Cli\u003E\u003Cspan style=\"font-family: inherit;\"\u003ETo find shortest path between two nodes u and v\u003C\/span\u003E\u003C\/li\u003E\u003Cli\u003E\u003Cspan style=\"font-family: inherit;\"\u003ETo test\u0026nbsp;\u003C\/span\u003Ebipartite-ness\u0026nbsp;\u003Cspan style=\"font-family: inherit;\"\u003E\u0026nbsp;of a graph\u003C\/span\u003E\u003C\/li\u003E\u003Cli\u003E\u003Cspan style=\"font-family: inherit;\"\u003ETo find all nodes within one connected component\u003C\/span\u003E\u003C\/li\u003E\u003C\/ol\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit;\"\u003ECode\u003C\/span\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/d4464143f885d0530eda.js\"\u003E\u003C\/script\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit;\"\u003EDriver program\u003C\/span\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cscript src=\"https:\/\/gist.github.com\/jitsceait\/308b025046db47fdb1e2.js\"\u003E\u003C\/script\u003E\u003Cb\u003E\u003Cspan style=\"font-family: inherit;\"\u003EGraph creation code can be used from DFS.\u003C\/span\u003E\u003C\/b\u003E \u003Cbr \/\u003E\u003Ch2\u003E\u003Cb\u003E\u003Cspan style=\"font-family: Courier New, Courier, monospace; font-size: large;\"\u003EComplexity Analysis\u003C\/span\u003E\u003C\/b\u003E\u003C\/h2\u003E\u003Cdiv\u003E\u003Cspan style=\"font-family: inherit;\"\u003EComplexity of Depth First Search is O(m+n) where m is number of vertex and n is number of edges.\u003C\/span\u003E\u003C\/div\u003E\u003Cspan style=\"font-family: inherit;\"\u003EComplexity of Breadth First Search is O(m +n) where m and n have same meaning as above.\u003C\/span\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/algorithmsandme.blogspot.com\/feeds\/3866324507436665576\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/graph-traversals.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/3866324507436665576"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/2585955070696911170\/posts\/default\/3866324507436665576"},{"rel":"alternate","type":"text/html","href":"http:\/\/algorithmsandme.blogspot.com\/2014\/06\/graph-traversals.html","title":"Graph Traversals"}],"author":[{"name":{"$t":"Jitendra Sangar"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07885594236543253450"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"14","height":"32","src":"http:\/\/1.bp.blogspot.com\/_UinON8Bx_II\/SW9pX_EYgiI\/AAAAAAAAAEE\/kfa2A_iXtTE\/S220\/jjitu.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/4.bp.blogspot.com\/-AIXNeZhb6rU\/U5RQMfks1lI\/AAAAAAAABEE\/bYlshSXHAOM\/s72-c\/graph-traversal+(1).png","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});